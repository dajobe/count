#!/usr/local/bin/perl -w
#
# $Source: /home/dajobe/dev/count/repo/count/count,v $
#
# $Id: count,v 1.3 1997-02-17 18:27:08 cmdjb Exp $
#
# USAGE:
#
#   count <field-ranges> [files...]
#
# where <field-ranges> is list of comma-separated ranges of fields of the form 
# field1-field2, field or '-' for the entire entry. e.g.:
#
#  count 0,3,5-7 file
#  count 0,1
#  count 2,- file1 file2
#  count 5 -
#  count 5
#  (last two are equivalent)
#
# Count the entries in the given whitespace-separated field (from 0)
# in the given files and report the results, sorted with most populal
# first in order with percentages and totals.
#
# (C) Copyright 1996 Dave Beckett <D.J.Beckett@ukc.ac.uk>
# University of Kent at Canterbury
#

require 5.000;

use strict;

use Carp;

warn <<"EOT" and exit 0 if !@ARGV;
Usage:
  count <field-ranges> [files...]
where
  <field-ranges> is field1-field2, field or '-' for entire line
  files can include '-' for stdin or assumes '-' if no files given
EOT

&::main(@ARGV);

exit 0;


sub main {
  my($field_nos, @files)=@_;

  @files='-' if !@files;

  # Parse fields arg to get ranges
  my(@fields);
  {
    # Build list of fields without duplicates
    my(%fields_seen);
    foreach (split (/,/, $field_nos)) {
      if (/^(\d+)-(\d+)$/) {
	foreach ($1..$2) {
	  push(@fields, $_), $fields_seen{$_}=1 if !$fields_seen{$_};
	}
      } elsif (/^(-|\d+)$/) {
	push(@fields, $_), $fields_seen{$_}=1 if !$fields_seen{$_};
      } else {
	croak "I don't understand range '$_'\n";
      }
    }
  }

  my %db;
  my %totalc;
  # Init value lengths
  my %max_valen=map {$_ => 0} @fields; # B5 joke

  my $file;
  foreach $file (@files) {
    open (::IN, $file) or carp "Cannot open $file - $!\n", next;
    
    while(<IN>) {
      chop;
      my $field;
      foreach $field (@fields) {
	my $value=($field eq '-') ? $_ : (split(/\s+/))[$field];

	next if !defined $value;

	$db{$field}{$value}++; $totalc{$field}++;

	$max_valen{$field}=length($value) if length($value) > $max_valen{$field};
      }
    }
    close(IN);
  }

  # Build count lengths
  my %max_clen;
  {
    my $field;
    foreach $field (@fields) {
      $max_clen{$field}=0;
      my $db_ref=$db{$field};
      foreach (values %$db_ref) {
	$max_clen{$field}=length($_) if length($_) > $max_clen{$field}
      }
    }
  }


  # Output results
  {
    my $field;
    foreach $field (@fields) {
      my $db_ref=$db{$field};

      print "Summary for field $field\n\n";

      my(@entry_order)=sort {
	$db_ref->{$::b} <=> $db_ref->{$::a}
      } keys %$db_ref;

      my $this_max_valen=$max_valen{$field};
      my $this_max_clen=$max_clen{$field};
      my $this_totalc=$totalc{$field};

      my $format_str="%${this_max_valen}s %${this_max_clen}d %6.2f%%\n";
	
      my $entry;
      foreach $entry (@entry_order) {
	my $count=$db_ref->{$entry};
	my $pcent=int(10000*$count/$this_totalc)/100;
	print sprintf($format_str, $entry, $count, $pcent);
      }
      print "-" x $this_max_valen . " " . "-" x $this_max_clen . " -------\n";
      print sprintf($format_str, "Total", $this_totalc, 100.00);
    }
  }
}

# Local Variables:
# mode: perl
# End:
